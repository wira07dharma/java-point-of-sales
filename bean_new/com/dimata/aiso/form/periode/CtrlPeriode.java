/* Generated by Together */

package com.dimata.aiso.form.periode;

/* package java */
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;

/* package dimata */
import com.dimata.util.*;
import com.dimata.util.lang.I_Language;

/* package qdep */
import com.dimata.aiso.db.*;
import com.dimata.qdep.form.*;
import com.dimata.qdep.system.*;

/* package aiso */
import com.dimata.aiso.entity.periode.*;
//import com.dimata.aiso.session.periode.*;

public class CtrlPeriode implements I_Language {
    public static int RSLT_OK = 0;
    public static int RSLT_UNKNOWN_ERROR = 1;
    public static int RSLT_MULTIPLE_DATE = 2;
    public static int RSLT_FORM_INCOMPLETE = 3;
    
    public static String[][] resultText = {
        {"Berhasil !", "Tidak dapat diproses", "Tanggal awal sama","Data tidak lengkap"},
        {"Ok", "Can not process", "Duplicate start date", "Data incomplete"}
    };
    
    public static int NO_ERR = 0;
    public static int ERR_START_DATE = 1;
    public static int ERR_DUE_DATE = 2;
    public static int ERR_LAST_ENTRY = 3;
    public static int ERR_POSTED = 4;
    
    public static String[][] errorText = {
        {" ","Tanggal awal tidak sesuai","Tanggal akhir tidak sesuai","Tanggal akhir entry tidak sesuai","Periode terakhir belum diposted"},
        {" ","Start date invalid","Due date invalid","Last entry date invalid","Last period haven't posted yet"}
    };
    
    public static int MSG_PER_OK = 0;
    public static int MSG_PER_LAST = 1;
    public static int MSG_PER_LAST_DUE = 2;
    public static int MSG_PER_DUE = 3;
    public static int MSG_PER_ERR = 4;
    public static int MSG_NO_PER = 5;
    public static int MSG_NO_TODAY = 6;
    
    public static String[][] msgPeriodeText = {
        {"","Hari ini adalah tanggal akhir entry data ...","Hari ini adalah tanggal akhir entry data dan akhir periode ...",
         "Hari ini adalah tanggal akhir periode ...","Periode ini harus ditutup ...",
         "Tidak ada periode yang aktif, silahkan setup new period ...","Tutup buku tidak bisa dilakukan, bukan akhir periode ..."},
         {"","Today is last entry date ...","Today is last entry date and due date for this period ...",
          "Today is due date for this period ...","This period must be close ...",
          "No period available, please setup new period ...","Close book cannot executed, not due date of periode ..."}
    };
    
    private int start = 0;
    private String msgString = "";
    private int iErrCode = 0;
    private Periode periode;
    private PstPeriode pstPeriode;
    private FrmPeriode frmPeriode;
    private int language= LANGUAGE_DEFAULT;
    private String messageErr = "";
    
    public CtrlPeriode(HttpServletRequest request) {
        msgString = "";
        periode = new Periode();
        try{
            pstPeriode = new PstPeriode(0);
        }catch(Exception e){}
        frmPeriode = new FrmPeriode(request, periode);
    }
    
    
    private String getSystemMessage(int msgCode){
        switch (msgCode){
            case I_DBExceptionInfo.MULTIPLE_ID :
                this.frmPeriode.addError(frmPeriode.FRM_TGLAWAL, resultText[language][RSLT_MULTIPLE_DATE] );
                return resultText[language][RSLT_MULTIPLE_DATE];
            default:
                return resultText[language][RSLT_UNKNOWN_ERROR];
        }
    }
    
    private int getControlMsgId(int msgCode){
        switch (msgCode){
            case I_DBExceptionInfo.MULTIPLE_ID :
                return RSLT_MULTIPLE_DATE;
            default:
                return RSLT_UNKNOWN_ERROR;
        }
    }
    
    public Periode getPeriode() {
        return periode;
    }
    
    
    public FrmPeriode getForm() {
        return frmPeriode;
    }
    
    public String getMessage(){
        return msgString;
    }
    
    public int getErrCode(){
        return iErrCode;
    }
    
    public int getStart() {
        return start;
    }
    
    public int action(int cmd, long IDPeriode, int monthInterval, int lastEntryDuration) 
    {
        this.start = start;
        msgString = "";
        int excCode = I_DBExceptionInfo.NO_EXCEPTION;   
        int rsCode = RSLT_OK; 
        
        switch (cmd) 
        {
            case Command.ADD : 
                    break;
            
            case Command.SAVE :
                frmPeriode.requestEntityObject(periode);
                
                Date newStartDate = periode.getTglAwal();
                Date newDueDate = periode.getTglAkhir();
                Date newLastEntry = periode.getTglAkhirEntry();
                
                if (newStartDate == null || newDueDate == null) {
                    newStartDate = PstPeriode.getFirstDateOfNewPeriod();
                    int year = newStartDate.getYear();
                    int month = newStartDate.getMonth() + monthInterval - 1;
                    int date = newStartDate.getDate();
                    GregorianCalendar gregCal = new GregorianCalendar(year, month, date);
                    date = gregCal.getActualMaximum(gregCal.DAY_OF_MONTH);
                    newDueDate = new Date(year, month, date);
                    periode.setTglAwal(newStartDate);
                    periode.setTglAkhir(newDueDate);
                }
                
                if (frmPeriode.errorSize() > 0) {
                    msgString = FRMMessage.getMsg(FRMMessage.MSG_INCOMPLATE);
                    return RSLT_FORM_INCOMPLETE ;
                }
                
                //int validPeriod = isValidPeriod(IDPeriode, newStartDate, newDueDate, newLastEntry, monthInterval, lastEntryDuration);
                int validPeriod = NO_ERR;
                if (validPeriod == NO_ERR) {
                    // set data that didn't got from form
                    periode.setOID(IDPeriode);
                    
                    if (IDPeriode > 0) {
                        Periode objPeriode = null;
                        periode.setPosted(PstPeriode.PERIOD_PREPARE_OPEN);
                        try {
                            objPeriode = PstPeriode.fetchExc(IDPeriode);
                            periode.setPosted(objPeriode.getPosted());
                        } catch (Exception error) {
                            System.out.println(error.toString());
                        }
                    } else if (PstPeriode.getCount("") > 0)
                        periode.setPosted(PstPeriode.PERIOD_PREPARE_OPEN);
                    else
                        periode.setPosted(PstPeriode.PERIOD_OPEN);
                    
                    long oid = 0;
                    if (periode.getOID() == 0) {
                        try {
                            oid = pstPeriode.insertExc(this.periode);
                            msgString = FRMMessage.getMsg(FRMMessage.MSG_SAVED);
                        } catch (DBException dbexc) {
                            excCode = dbexc.getErrorCode();
                            msgString = getSystemMessage(excCode);
                            return getControlMsgId(excCode);
                        } catch (Exception exc) {
                            msgString = getSystemMessage(I_DBExceptionInfo.UNKNOWN);
                            return getControlMsgId(I_DBExceptionInfo.UNKNOWN);
                        }
                    } else {
                        try {
                            oid = pstPeriode.updateExc(this.periode);
                            msgString = FRMMessage.getMsg(FRMMessage.MSG_UPDATED);
                        } catch (DBException dbexc) {
                            excCode = dbexc.getErrorCode();
                            msgString = getSystemMessage(excCode);
                        } catch (Exception exc) {
                            msgString = getSystemMessage(I_DBExceptionInfo.UNKNOWN);
                        }
                    }
                } else {
                    rsCode = FRMMessage.ERR_SAVED;
                    msgString = errorText[language][validPeriod];
                }
                break;
            case Command.EDIT :
                if (IDPeriode != 0){
                    try {
                        periode = (Periode)pstPeriode.fetchExc(IDPeriode);
                    } catch (DBException dbexc){
                        excCode = dbexc.getErrorCode();
                        msgString=getSystemMessage(excCode);
                    } catch (Exception exc){
                        msgString=getSystemMessage(I_DBExceptionInfo.UNKNOWN);
                    }
                }
                break;
                
            case Command.ASK :
                if ((IDPeriode > 0)||(IDPeriode < 0)){
                    try {
                        periode = (Periode) pstPeriode.fetchExc(IDPeriode);
                        msgString = FRMMessage.getMsg(FRMMessage.MSG_ASKDEL);
                    } catch (DBException dbexc){
                        excCode = dbexc.getErrorCode();
                        msgString=getSystemMessage(excCode);
                    } catch (Exception exc){
                        msgString=getSystemMessage(I_DBExceptionInfo.UNKNOWN);
                    }
                }
                break;
            case Command.DELETE :
                try {
                    PstPeriode.deleteExc(IDPeriode);
                    msgString = FRMMessage.getMsg(FRMMessage.MSG_DELETED);
                } catch (DBException dbExc) {
                    excCode = dbExc.getErrorCode();
                    msgString = getSystemMessage(excCode);
                } catch (Exception exc) {
                    msgString = getSystemMessage(I_DBExceptionInfo.UNKNOWN);
                }
                break;
                
            default:
        }
        return rsCode;
    }
    
    /*
     * This method use to get difference day between two date
     * if actualDate >= refDate, it will return postive (decimal) value
     * else it will return negative value, this value show the difference of both date
     */
    /*
    public static double getDiffDay(Date actualDate,
    Date refDate) {
        long actualTime = actualDate.getTime();
        long refTime = refDate.getTime();
        
        long oneDayTime = 24 * 60 * 60 * 1000;  // in mili seconds
        
        double diffDay = (double) (actualTime - refTime) / oneDayTime;
        return diffDay;
    }
    */
    
    /*
     * This method used to check if new entry periode is valid or not 
     */
    /*
    public static int isValidPeriod(long idPeriod, Date newStartDate, Date newDueDate, Date newLastEntry, int monthInterval, int lastEntryDuration) 
    {
        Calendar newCalendar = Calendar.getInstance();
        newCalendar.setTime(newDueDate);
        Vector listPeriod = new Vector(1,1);
        Date lastStartDate = null;
        Date lastDueDate = null;
        int posting = PstPeriode.PERIOD_OPEN;
        int valid = NO_ERR;        
        
        int yearInterval = newDueDate.getYear() - newStartDate.getYear();
    
        // add new period
        if (idPeriod == 0) 
        {
            listPeriod = PstPeriode.getLastPeriod();
            
            // no period available
            if (listPeriod.size() == 0) {
                if (newStartDate.getDate() != 1)
                    return ERR_START_DATE;
                if (newDueDate.getDate() != newCalendar.getActualMaximum(newCalendar.DAY_OF_MONTH))
                    return ERR_DUE_DATE;
                if (newDueDate.before(newStartDate))
                    return ERR_DUE_DATE;
                if ((yearInterval * 12) + newDueDate.getMonth() - newStartDate.getMonth() != monthInterval - 1)
                    return ERR_DUE_DATE;
                if (newLastEntry.before(newDueDate))
                    return ERR_LAST_ENTRY;
                if ((newLastEntry.getDate() > lastEntryDuration) && (newLastEntry.compareTo(newDueDate) != 0))
                    return ERR_LAST_ENTRY;
                if (getDiffDay(newLastEntry, newDueDate) > lastEntryDuration)
                    return ERR_LAST_ENTRY;
                return NO_ERR;
                
                // period available
            } else {
                Periode per = (Periode) listPeriod.get(0);
                lastDueDate = per.getTglAkhir();
                posting = per.getPosted();
                
                // period have posted
                //if (posting == PstPeriode.PERIOD_CLOSED) {
                if (newStartDate.before(lastDueDate))
                    return ERR_START_DATE;
                if (newStartDate.getDate() != 1)
                    return ERR_START_DATE;
                if (newDueDate.getDate() != newCalendar.getActualMaximum(newCalendar.DAY_OF_MONTH))
                    return ERR_DUE_DATE;
                if (newDueDate.before(newStartDate))
                    return ERR_DUE_DATE;
                if ((yearInterval * 12) + newDueDate.getMonth() - newStartDate.getMonth() != monthInterval - 1)
                    return ERR_DUE_DATE;
                if (newLastEntry.before(newDueDate))
                    return ERR_LAST_ENTRY;
                if ((newLastEntry.getDate() > lastEntryDuration) && (newLastEntry.compareTo(newDueDate) != 0))
                    return ERR_LAST_ENTRY;
                if (getDiffDay(newLastEntry, newDueDate) > lastEntryDuration)
                    return ERR_LAST_ENTRY;
                return NO_ERR;
                // period haven't posted yet
                //}else{ return  ERR_POSTED; }
            }
            // update current period
        } else {
            listPeriod = PstPeriode.getLastPeriod();
            Date firstTransactionJournal = SessPeriode.getFirstTransactionJournal(idPeriod);
            Date lastTransactionJournal = SessPeriode.getLastTransactionJournal(idPeriod);
            
            // no last period available
            if(listPeriod.size()==1){
                System.out.println("no last period");
                // there are transaction during current period
                if(firstTransactionJournal!=null && lastTransactionJournal!=null){
                    if(newStartDate.after(firstTransactionJournal)){ return  ERR_START_DATE; }
                    else if(newDueDate.before(lastTransactionJournal)){ return  ERR_DUE_DATE; }
                    else if(newStartDate.getDate()!=1){ return ERR_START_DATE; }
                    else if(newDueDate.getDate()!=newCalendar.getActualMaximum(newCalendar.DAY_OF_MONTH)){ return ERR_DUE_DATE; }
                    else if(newDueDate.before(newStartDate)){ return  ERR_DUE_DATE; }
                    else if((yearInterval*12)+newDueDate.getMonth()-newStartDate.getMonth()!=monthInterval-1){ return  ERR_DUE_DATE; }
                    else if(newLastEntry.before(newDueDate)){ return  ERR_LAST_ENTRY; }
                    else if((newLastEntry.getDate()>lastEntryDuration)&&(newLastEntry.compareTo(newDueDate)!=0)){ return  ERR_LAST_ENTRY; }
                    else if (getDiffDay(newLastEntry, newDueDate) > lastEntryDuration)
                        return ERR_LAST_ENTRY;
                    
                    else{ return  NO_ERR; }
                    
                    // no transaction during current period
                }else{
                    if(newStartDate.getDate()!=1){ return ERR_START_DATE; }
                    else if(newDueDate.getDate()!=newCalendar.getActualMaximum(newCalendar.DAY_OF_MONTH)){ return ERR_DUE_DATE; }
                    else if(newDueDate.before(newStartDate)){ return  ERR_DUE_DATE; }
                    else if((yearInterval*12)+newDueDate.getMonth()-newStartDate.getMonth()!=monthInterval-1){ return  ERR_DUE_DATE; }
                    else if(newLastEntry.before(newDueDate)){ return  ERR_LAST_ENTRY; }
                    else if((newLastEntry.getDate()>lastEntryDuration)&&(newLastEntry.compareTo(newDueDate)!=0)){ return  ERR_LAST_ENTRY; }
                    else if (getDiffDay(newLastEntry, newDueDate) > lastEntryDuration)
                        return ERR_LAST_ENTRY;
                    return  NO_ERR;
                }
            }
            
            // last period available
            if(listPeriod.size()>1){
                System.out.println("last period avaiable");
                Periode per = (Periode) listPeriod.get(0);
                lastDueDate = per.getTglAkhir();
                System.out.println(Formater.formatDate(lastDueDate,"MMMM dd,  yyyy"));
                posting = per.getPosted();
                
                // period have posted
                if(posting == PstPeriode.PERIOD_CLOSED){
                    System.out.println("closed");
                    // there are transaction during current period
                    if(firstTransactionJournal!=null && lastTransactionJournal!=null){
                        if(newStartDate.before(lastDueDate)){ return  ERR_START_DATE; }
                        else if(newStartDate.after(firstTransactionJournal)){ return  ERR_START_DATE; }
                        else if(newDueDate.before(lastTransactionJournal)){ return  ERR_DUE_DATE; }
                        else if(newStartDate.getDate()!=1){ return ERR_START_DATE; }
                        else if(newDueDate.getDate()!=newCalendar.getActualMaximum(newCalendar.DAY_OF_MONTH)){ return ERR_DUE_DATE; }
                        else if(newDueDate.before(newStartDate)){ return  ERR_DUE_DATE; }
                        else if((yearInterval*12)+newDueDate.getMonth()-newStartDate.getMonth()!=monthInterval-1){ return  ERR_DUE_DATE; }
                        else if(newLastEntry.before(newDueDate)){ return  ERR_LAST_ENTRY; }
                        else if((newLastEntry.getDate()>lastEntryDuration)&&(newLastEntry.compareTo(newDueDate)!=0)){ return  ERR_LAST_ENTRY; }
                        else if (getDiffDay(newLastEntry, newDueDate) > lastEntryDuration)
                            return ERR_LAST_ENTRY;
                        return  NO_ERR;
                        
                        // no transaction during current period
                    }else{
                        if(newStartDate.before(lastDueDate)){ return  ERR_START_DATE; }
                        else if(newStartDate.getDate()!=1){ return ERR_START_DATE; }
                        else if(newDueDate.getDate()!=newCalendar.getActualMaximum(newCalendar.DAY_OF_MONTH)){ return ERR_DUE_DATE; }
                        else if(newDueDate.before(newStartDate)){ return  ERR_DUE_DATE; }
                        else if((yearInterval*12)+newDueDate.getMonth()-newStartDate.getMonth()!=monthInterval-1){ return  ERR_DUE_DATE; }
                        else if(newLastEntry.before(newDueDate)){ return  ERR_LAST_ENTRY; }
                        else if((newLastEntry.getDate()>lastEntryDuration)&&(newLastEntry.compareTo(newDueDate)!=0)){ return  ERR_LAST_ENTRY; }
                        else if (getDiffDay(newLastEntry, newDueDate) > lastEntryDuration)
                            return ERR_LAST_ENTRY;
                        return  NO_ERR;
                    }
                    
                    // period haven't posted yet
                }else{ return  ERR_POSTED; }
            }
        }
        return valid;
    }
    */
    
    
    public int getStatusPeriod()
    {
        Vector currDate = PstPeriode.getCurrPeriod();
        if((currDate!=null) && (currDate.size()>0))
        {
            Periode per = (Periode) currDate.get(0);
            Date tempDate = new Date();
            Date toDayDate = new Date(tempDate.getYear(),tempDate.getMonth(),tempDate.getDate());

            if(per.getTglAkhirEntry().compareTo(toDayDate) == 0)
            {
                return MSG_PER_LAST;
            }
            
            if(per.getTglAkhirEntry().before(toDayDate))
            {
                return MSG_PER_ERR;
            }
        }
        else
        {
            return MSG_NO_PER;
        }
        return MSG_PER_OK;
    }  
    
}

